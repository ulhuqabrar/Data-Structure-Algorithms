# Problem: Palindrome Number ğŸš€  
**Link:** [Palindrome Number](https://leetcode.com/problems/palindrome-number/)  
**Difficulty:** Easy  
**Category:** Strings  
**Topics:** String Conversion, Two-Pointer Technique  

---

## ğŸ“Œ Problem Statement  
Given an integer `x`, return **true** if `x` is a palindrome, and **false** otherwise.  

A palindrome is a number that reads the same **forward** and **backward**.  

---

## ğŸ” Examples  

```cpp
Input: x = 121
Output: true
Explanation: 121 reads the same from left to right and right to left.

Input: x = -121
Output: false
Explanation: "-121" backwards is "121-", so itâ€™s not the same.

Input: x = 10
Output: false
Explanation: "10" backwards is "01", which is not equal.

ğŸ› ï¸ Constraints

    -2^31 <= x <= 2^31 - 1

    Follow-up: Solve it without converting the integer to a string.

ğŸ’¡ Approach

This solution converts the integer into a string, then checks if the string is the same when read forward and backward using a two-pointer technique.

Steps:

    Convert the integer to a string using to_string(x).

    Set two pointers:

        start â†’ beginning of the string

        end â†’ last character of the string

    While start < end:

        Compare s[start] and s[end]

        If they differ â†’ return false

        Otherwise move inward (start++, end--)

    If loop finishes without mismatches â†’ return true.

ğŸ§© Code Implementation

class Solution {
public:
    bool isPalindrome(int x) {
        string s = to_string(x);   // Convert integer to string
        int start = 0;             // Pointer at beginning
        int end = s.length() - 1;  // Pointer at end

        while (start < end) {
            if (s[start] != s[end]) {
                return false;      // If mismatch â†’ not a palindrome
            }
            start++;               // Move left pointer right
            end--;                 // Move right pointer left
        }

        return true;               // If loop finishes â†’ palindrome
    }
};

ğŸ–¥ï¸ Code Explanation (Line by Line)

    string s = to_string(x);

        Convert the integer into a string so we can easily access each digit.

    int start = 0; int end = s.length() - 1;

        start points to the first digit, end points to the last digit.

    while (start < end)

        Loop until the two pointers meet in the middle.

    if (s[start] != s[end]) return false;

        Compare characters at both ends.

        If they differ â†’ immediately conclude itâ€™s not a palindrome.

    start++; end--;

        Move inward: left pointer goes right, right pointer goes left.

    return true;

        If no mismatches were found, the number is a palindrome.

âœ… Example Run

For x = 121:

    Convert â†’ "121"

    Compare â†’ s[0] == s[2] â†’ 1 == 1 âœ”

    Move pointers inward â†’ s[1] == s[1] â†’ 2 == 2 âœ”

    All checks passed â†’ return true

ğŸ”‘ Key Takeaways

    Two-pointer technique is great for checking symmetry.

    Time Complexity: O(n), where n = number of digits.

    Space Complexity: O(n) (string conversion).

    Optimized Approach (Follow-up): Reverse half the number without converting to string.
